FileSystem
==============
# 과제 개요

본 과제에서는 현존하는 파일 시스템을 간략화 시킨 Simple File System(SFS)의 구현을 통한
파일시스템의 이해를 높이는 것을 목적으로 합니다. SFS는 실제 디스크를 사용 하는 것이 아닌, 파일을
통해 디스크를 시뮬레이션 하는 형태로 동작하는데, 과제에서는 주어진 디스크 이미지 파일을 사용하여
SFS와 관련된 명령어들을 구현하게 됩니다.

# Simple File System

본 과제에서는 실제 디스크를 사용 하는 것이 아닌, 디스크와 동등한 형태의 디스크 이미지 파일을
사용 하여 과제를 진행합니다.(과제 압축 파일 내 DISK1.img, DISK2.img, DISKFull.img) 이들 이미지들은
SFS에서 사용하는 레이아웃 형태로 포맷되어 있는데, disk_read(), disk_write() 함수를 통하여 실제
디스크와 같이 블록단위로 엑세스하게 됩니다. 파일시스템은 디스크의 가용한 블록(free blocks)들을 관리
하거나, 파일시스템 내 실제 파일을 관리 하기 위해 많은 방법들을 사용하는데, FAT이나 i-node와 같은
방법이 이에 해당합니다. SFS에서는 디렉토리 구조나 파일을 관리하기 위해 i-node를 사용하고, 가용한
블록(free blocks)들을 관리하기 위하여 비트맵 형태의 사용합니다. 

# SFS Layout

SFS에서 사용 하는 디스크 이미지는 다음과 같은 형태로 이루어져 있습니다. 아래 그림의 각 칸은
디스크의 한 블록을 나타내게 되는데 디스크의 첫 번째 블록에는 슈퍼블록이, 두 번째 블록에는 루트
디렉토리의 i-node가 위치하게 됩니다. 슈퍼블록이 포함하고 있는 정보, i-node가 유지하고 있는 정보들은
모두 sfs.h에 정의 되어 있습니다. 항상 첫 번째 두 번째 블록은 고정이며 세 번째 블록부터는 비트맵이
오게 되는데 비트맵의 블록 수는 디스크 전체 블록 수에 따라 유동적이게 됩니다. 비트맵은 특별한 구조를
가지지 않고 순수하게 비트맵 데이터만 유지하게 되는데, 즉 한 비트맵 블록은 512*8개의 비트를 가질 수
있으므로 512*8개 블록의 할당/해제 정보를 나타 낼 수 있게 됩니다.(512*8인 이유는 한 블록의
크기가 512byte이고, 1byte는 8bits 이기 때문입니다) 하나의 비트맵 블록만 사용하는 디스크의 가장
초기 상태에서는 1, 2, 3, 4번째 블록(Super block, Root Directory i-node block, bitmap block, Root
directory data block)만 사용 하고 있으므로 비트맵 블록의 1, 2, 3, 4번째 비트만 1로 표시되고 
나머지는 0으로 표시되게 됩니다(실제 비트맵 블록은 SFS에서 사용되는 전체 블록의 수의 따라 여러
개 사용 될 수 있습니다). SFS에서는 i-node에 관한 리스트 (i-list)가 존재 하지 않습니다. 수업시간에 다룬 파일 시스템 구조에서는 i-list가 존재해서 i-node와 데이터 블록(데이터, 디렉토리 블록)이 다른 곳에 구별되어 저장 됩니다. 반면에 SFS에서는 이러한 구분 없이 저장되고, 디스크에 존재하는 어떠한 블록도 i-node가 될 수 있습니다. 이러한 특징으로 인해 단순히
블록번호를 i-node 번호로 사용할 수 있고, 따라서 새로운 i-node 할당은 디스크에서 사용되지 않는
한 블록을 할당하는 것과 일치 하게 됩니다.(i-node를 할당하기 위해 디스크의 한 블록을
할당했다면, 해당 블록의 번호가 i-node 번호 입니다)

# 과제 파일 설명

## DISK1.img, DISK2.img, DISKFULL.img
과제에서 사용할 디스크 이미지 파일입니다. 두 파일 모두 위와 같이 SFS에서 사용하는 형태로
이루어져 있고 DISK1.img는 몇 개의 디렉토리 및 파일이 포함된 이미지, DISK2.img는 초기 상태의
이미지입니다. DISKFULL.img 는 꽉찬 디스크의 이미지 파일입니다.

## sfs_disk.h, sfs_disk.c
DISK1.img, DISK2.img를 사용하기 위한 인터페이스입니다. 디스크 형태로 사용하기 위하여 블록단위로
엑세스할 수 있는 함수들이 정의되어 있습니다. 해당 함수들은 모두 구현이 완료되어 있는 상태로 수정
할 수 없고, DISK1.img, DISK2.img에 대한 읽기와 쓰기는 반드시 이 파일에 정의된 인터페이스를
사용해야 합니다. ※ sfs_disk.h에 정의된 함수 중 과제에서 사용 할 인터페이스(함수)는 disk_read()와
disk_write()뿐입니다. disk_blocksize도 있긴 하지만 블록사이즈는 sfs.h에 정의된 것을 사용 하는 것이
좋습니다. disk_read와 disk_write에 대해 간략히 설명을 하면 두 함수 모두 첫 번째 인자로 버퍼의
주소를 받습니다.(블록에 대한 연산이므로 버퍼의 크기는 반드시 블록사이즈와 같거나 커야 합니다) 두
번째 인자는 실제로 쓰거나 읽을 블록의 번호를 받게 되는데 예를 들어 disk_read(buf, 1)와 같이 호출
한다면, SFS에서 블록 번호가 1인 곳에 위치하는 데이터는 루트 디렉토리의 i-node 이므로 buf에는
루트 디렉토리의 i-node가 읽어지게 됩니다.

## sfs.h
SFS에서 사용할 구조체 및 매크로가 정의되어 있습니다. 매크로로는 SFS의 블록사이즈나 매직넘버 등의
정보와, 블록 당 비트 수, 블록 당 디렉토리 엔트리 수와 같이 자주 쓰이는 연산 등이 정의되어
있습니다. 또한 본 과제에 있어 가장 많이 사용될 i-node 구조와 디렉토리 엔트리 구조가 정의되어
있습니다. 과제를 진행 할 때 i-node와 디렉토리 엔트 리의 대한 이해도가 낮다면 과제를 진행하는데
어려움이 있을 수 있습니다. ※ sfs_inode의 sfi_linkcount는 하드 링크를 위한 변수로 본 과제에서는 사용하지 않습니다. sfs.h에
정의되어 있는 구조체를 변경하지 마세요. 정상적으로 동작하지 않을 수 있습니다.

## sfs_main.c
과제에서 사용 할 메인 함수 부분으로 과제에 필요한 쉘이 구현되어 있습니다. 과제에서 구현할
명령어에 대한 함수를 호출 합니다.

## sfs_func.h sfs_func_hw.c
sfs_func.h 파일에는 본 과제에서 구현해야 할 명령어들의 프로토타입이 정의되어 있습 니다. 본
과제에서는 모든 구현을 sfs_func_hw.c에만 하게 됩니다. sfs_func_hw.c 파일에는 현재 디렉토리를
나타내는 sd_cwd와 슈퍼블록의 정보를 가지고 있는 spb를 전역변수로 가지고 있습니다. 각각의
명령어에서 필요시 이 두 변수의 값을 조정 하거나 참조함으로써 명령어를 구현 할 수있습니다. 숙제
제출시 sfs_func_hw.c 함수만 제출 하면 되고 다른 *.c *.h 파일은 숙제 검사 시 다른 버전이 사용될
수 있으므로 변경하면 안 됩니다. ※ sfs_main.c에 있는 명령어 함수 중 구현이 안 된 함수는 해당 함수를 sfs_func_hw.c 에
printf(“Not Implemented\n”); 문장을 넣어 임시로 완성하여 컴파일이 가능하도록 합니다.

# 과제 제한 사항
1. 모든 명령어의 구현에는 에러 상황에 대한 처리를 포함해야 합니다. 실제 쉘에서 명령어를 수행
했을 때 처리되는 에러들을 포함 하시면 되는데 error_message() 함수를 사용하여 에러 메시지를
출력하기 바랍니다. (error_message() 함수에 없는 메시지는 별도로 출력하여도 됩니다) 명령어
수행 시 발생할 수 있는 에러 중 error_message() 함수의 메시지에 해당하는 에러는 반드시
처리하기 바랍니다. 각 명령어 설명에 발생 가능한 에러 상황에 대한 설명이 있습니다. 

2. 과제에서 파일 수정은 sfs_func_hw.c만 가능합니다. 내부적으로 함수를 만들어서 사용하는 것은
무방하고, 명령어의 기능을 적절히 제공 할 수 있으면 됩니다. 

3. 한 명령어가 끝날 때에는 디스크 이미지의 모든 변경 사항이 디스크 이미지로 쓰여 져야
합니다. 기존의 파일시스템의 경우 버퍼캐시 등을 이용하여 디스크의 변경 사항이 바로 쓰여지지
않고 주기적으로 쓰여 지지만, SFS에서는 버퍼캐시가 없으므로 명령어가 실행 될 동안 변경된
디스크 이미지는 명령어가 끝나기 전에 반드시 쓰여져야 합니다. 즉, 비트맵 등을 메모리상에서
관리하면 안 됩니다. 필요시 디스크에서 읽은 후 다시 디스크에 쓰는 형태로 관리 되어야 합니다. 

4. 디렉토리 엔트리의 정보는 i-node내의 direct blocks에만 저장하고 indirect block(single indirect
pointer)에 저장 하는 것은 사용하지 않습니다. 따라서 한 디렉토리가 가질 수 있는 최대 엔트리
개수는 SFS_DENTRYPERBLOCK*SFS_NDIRECT가 됩니다. 

5. 모든 경로(path)를 입력 받는 명령어들에 대해서(ls, cd, mkdir, 등) 실제 쉘에서 사용하는 경로가
아닌 디렉토리 내의 실제 파일이나 디렉토리 이름을 입력 받는다고 가정합니다. 즉
“/os/homework” 또는 “./func.c” 같이 경로가 아닌 “a_file”, “b_directory” 같은 파일 또는 디렉토리
이름이 해당 명령어의 인자(path)로 사용된다고 가정합니다. 

# 명령어 설명
※ 명령어 신택스 (syntax) 는 “명령어 [인자]” 또는 “명령어 인자1 인자2” 이며 [인자]는 “인자” 가 있거나 아무것도 없는 것을 나타냅니다. 인자가 path 인 경우 파일 또는 디렉토리
이름만 사용되고 따라서 path에 “/” 들어가는 경우는 지원하지 않아도 됩니다.

## mount disk_image_file_name
mount 명령어는 디스크 파일 이미지를 사용하고자 할 때 사용하는 명령어입니다. 다른 명령어를
사용하기 전에 mount가 선행되어야 합니다. mount 명령어에서는 슈퍼블록을 읽고 매직넘버 등을
확인하는 작업을 수행합니다. (mount 명령어는 예제로 제공이 되므로 다른 명령어 구현 시 참고
바랍니다)

## umount
umount 명령어는 사용하던 디스크 파일 close하고 슈퍼블록과 current working directory 구조체
(spb, sd_cwd)를 초기화하여 다음 mount 명령어를 사용 할 수 있도록 하여 줍니다. (umount
명령어는 제공 되므로 사용만 하면 됩니다.)
